"""

Code d'exploitation du système de télémétrie

"""

import matplotlib.pyplot as plt
import numpy as np
import time

#%% Calibration

cali = np.loadtxt("calibration 26 decembre.csv", skiprows=1, unpack=True, delimiter=',')
pot_invers = True

# progressivité du vélo 
shock_travel = [0, 3.3, 6.6, 10, 13.4, 16.9, 20.5, 24.1, 27.7, 31.4, 35.1, 38.9, 42.7, 46.5]
rear_travel = np.linspace(0, 130, 14)
rc = np.polyfit(shock_travel, rear_travel, 3)

# variables de l'expérience
debattement_avant = 130 #en mm
debattement_arriere = 130 #en mm
debattement_shock = 47 #en mm
longueur_pot_av = 150 #en mm
longueur_pot_ar = 100 #en mm
max_pot_av = 26270
max_pot_ar = 26270

if pot_invers:
    cali[1] = [max_pot_ar - cali[1][i] for i in range(len(cali[1]))]
    cali[2] = [max_pot_av - cali[2][i] for i in range(len(cali[2]))]

pot_ar_max_travel = (max(cali[1]) - min(cali[1])) * (longueur_pot_ar / max_pot_ar)

#%% choix du fichier

fichier = "run 7.csv"
nrun = "7"
probleme = ""#"(saut de chaine), temps corrigé"
simulation = False
vitesse_log = True
t1, t2, t3, t4 = 0, 0, 0, 0
#t1, t2, t3, t4 = 76.4, 103.4, 158, 0 #run 1
#t1, t2, t3, t4 = 67.3, 79, 140.5, 0 #run 2
#t1, t2, t3, t4 = 118.8, 0, 0, 0 #run 4
#t1, t2, t3, t4 = 61.4, 82.2, 108.8, 117.4 #run 5

#t1, t2, t3, t4 = 34, 51.8, 86.7, 112.4


#%% fonctions de traitement
def wheel_travel(pot: list, front=True) -> list: #conversion potentiometre -> wheel travel
    n = len(pot)
    pot_conv = [0]*n
    if front:
        zero_av = min(pot) * (longueur_pot_av / max_pot_av)
        for i in range(n):
            pot_conv[i] = pot[i] * (longueur_pot_av / max_pot_av) - zero_av
    else: #rear
        zero_ar = min(pot) * (longueur_pot_ar / max_pot_ar)    
        for i in range(n):
            pot_conv[i] = (pot[i] * (longueur_pot_ar / max_pot_ar) - zero_ar) * (debattement_shock / pot_ar_max_travel)
        #conversion de pot à wheel travel
        for i in range(n):
            pot_conv[i] = rc[3] + rc[2]*pot_conv[i] + rc[1]*pot_conv[i]**2 + rc[0]*pot_conv[i]**3      
    return pot_conv

def dynamic_sag(av: list, ar: list) -> list:
    """
    av et ar sont les outputs de wheel_travel
    renvoie des listes de % d'utilisation des suspensions par tranche
    """
    plage_av = [0]*131
    plage_ar = [0]*131
    
    #stats roue avant
    n = len(av)
    for i in range(n):
        if int(av[i]) >= 0 and int(av[i]) <= 130:
            plage_av[int(av[i])] += 100/n
        elif int(av[i]) < 0:
            plage_av[0] += 100/n
        elif int(av[i]) > 130:
            plage_av[-1] += 100/n
    
    #stats roue arriere
    n = len(ar)
    for i in range(n):
        if int(ar[i]) >= 0 and int(ar[i]) <= 130:
            plage_ar[int(ar[i])] += 100/n
        elif int(ar[i]) < 0:
            plage_ar[0] += 100/n
        elif int(ar[i]) > 130:
            plage_ar[-1] += 100/n
       
    return plage_av, plage_ar

def wheel_speed(t, av, ar):
    dav = [(av[i+1]-av[i-1])/(t[i+1]-t[i-1]) for i in range(1, len(t)-1)]
    dar = [(ar[i+1]-ar[i-1])/(t[i+1]-t[i-1]) for i in range(1, len(t)-1)]
    dt = t[1:-1]
    return dt, dav, dar

def repartition_vitesse(dav, dar):
    """
    in : dav et dar sont les outputs de wheel_speed
    out : liste de repartion des couples de vitesse dans l'ordre :
        0, haut gauche 
        1, haut droite
        2, bas gauche
        3, bas droite
    """
    repart_d = [0]*4
    n = len(dar)
    for i in range(n):
        if dar[i] > 0:
            if dav[i] > 0:
                repart_d[1] += 100/n
            else:
                repart_d[3] += 100/n
        else:
            if dav[i] > 0:
                repart_d[0] += 100/n
            else:
                repart_d[2] += 100/n
    return repart_d


def var_nuage_pos(av, ar):
    reg_nuage = np.polyfit(ar, av, 1)
    x_nuage = np.linspace(0, 130, 14)
    y_nuage = [reg_nuage[0]*x_nuage[i] + reg_nuage[1] for i in range(len(x_nuage))]
    return x_nuage, y_nuage, reg_nuage[0]


def tranche_vitesse(dav: list, dar: list, echelle_log=False) -> list: #affichage graphique
    """
    av et ar sont les outputs de wheel_speed
    renvoie des listes de % d'utilisation des suspensions par tranche de vitesse
    """
    largeur = 50 #mm/s
    Mdav, mdav = round(max(dav), -3), abs(round(min(dav), -3))
    Mdar, mdar = round(max(dar), -3), abs(round(min(dar), -3))
    lv = int((Mdav + mdav) / largeur)+1
    lr = int((Mdar + mdar) / largeur)+1
    x_plage_dav = np.linspace(-mdav, Mdav, lv)
    x_plage_dar = np.linspace(-mdar, Mdar, lr)    
    y_plage_dav = [0]*lv
    y_plage_dar = [0]*lr
    
    #stats roue avant
    n = len(dav)
    for i in range(n):
        for j in range(1, lv-1):
            if x_plage_dav[j-1] <= dav[i] <= x_plage_dav[j+1]:
                y_plage_dav[j] += 100/n
                break
    
    #stats roue arriere
    n = len(dar)
    for i in range(n):
        for j in range(1, lr-1):
            if x_plage_dar[j-1] <= dar[i] <= x_plage_dar[j+1]:
                y_plage_dar[j] += 100/n
                break
    
    if echelle_log:
        for i in range(len(y_plage_dar)):
            y_plage_dar[i] = np.log(1+y_plage_dar[i])
        for i in range(len(y_plage_dav)):
            y_plage_dav[i] = np.log(1+y_plage_dav[i])
            
    return x_plage_dav, x_plage_dar, y_plage_dav, y_plage_dar

def tranche_vitesse_max(dav: list, dar: list, max_v=500) -> list: #affichage valeur
    """
    av et ar sont les outputs de wheel_speed
    renvoie des listes de % d'utilisation des suspensions par tranche de vitesse
    """
    largeur = 1 #mm/s
    lv = int(2*max_v / largeur)+1
    lr = lv
    x_plage_dav = np.linspace(-max_v, max_v, lv)
    x_plage_dar = x_plage_dav  
    y_plage_dav = [0]*lv
    y_plage_dar = [0]*lr
    
    #stats roue avant
    n = len(dav)
    for i in range(n):
        for j in range(1, lv-1):
            if x_plage_dav[j-1] <= dav[i] <= x_plage_dav[j+1]:
                y_plage_dav[j] += 100/n
                break
            
    #stats roue arriere
    n = len(dar)
    for i in range(n):
        for j in range(1, lr-1):
            if x_plage_dar[j-1] <= dar[i] <= x_plage_dar[j+1]:
                y_plage_dar[j] += 100/n
                break
            
    y_max_dav, y_max_dar = max(y_plage_dav), max(y_plage_dar)
    
    for i_av in range(len(x_plage_dav)):
        if y_plage_dav[i_av] == y_max_dav:
            x_max_dav = x_plage_dav[i_av]
            
    for i_ar in range(len(x_plage_dar)):
        if y_plage_dar[i_ar] == y_max_dar:
            x_max_dar = x_plage_dar[i_ar]
    
    return x_max_dav, x_max_dar


def data_sag(pav, par):
    mav = max(pav[15:])
    for i in range(len(pav)):
        if pav[i] == mav:
            sagav = int(plage_bar[i])
    mar = max(par[15:])
    for i in range(len(par)):
        if par[i] == mar:
            sagar = int(plage_bar[i])
    return sagav, sagar


def delta_hist(delta) -> list:
    """
    av et ar sont les outputs de wheel_travel
    renvoie des listes de % de temps passé par delta de debattement
    """
    hist = [0]* 201
    n = len(delta)
    for i in range(n):
        hist[100+int(delta[i])] += 100/n
    return hist


def stat_delta(histo):
    scnd_max = max(max(histo[:100]), max(histo[101:]))
    k = 0
    for i in range(201):
        if histo[i] == scnd_max:
            k = i
    return int(abs(100-k)*(k-100)/abs(k-100))
    

def Vect_Acc(Ax, Ay, Az):
    Acc = [0]*len(Ax)
    for i in range(len(Ax)):
        Acc[i] = np.sqrt(Ax[i]**2 + Ay[i]**2 + Az[i]**2) - 10
    return Acc


def data_acc(Acc):
    return round(np.mean(Acc)/10, 2), round(max(Acc)/10, 1)


def bottom_compte(t, av, ar):
    """
    Renvoie le temps passé à bottom les suspensions
    """
    periode = t[-1]/len(t)
    botav, botar = 0, 0
    for i in range(len(t)):
        if av[i] > 0.96*debattement_avant:
            botav += 1
        if ar[i] > 0.96*debattement_arriere:
            botar += 1
    botav *= periode
    botar *= periode
    return botav, botar

def check_temps(t, t1=0, t2=0, t3=0, t4=0):
    t = list(t)
    if t1 == 0:
        return t
    pas = t[-1]/len(t)
    for i in range(len(t)):
        if t[i] >= t1:
            i1 = i
            break
    if t2 == 0:
        n = i1
        return np.linspace(0, pas*n, n)
    for i in range(len(t)):
        if t[i] >= t2:
            i2 = i
            break
    if t3 == 0:
        n = len(t) - (i2-i1)
        return np.linspace(0, pas*n, n)
    for i in range(len(t)):
        if t[i] >= t3:
            i3 = i
            break
    if t4 == 0:
        n = i3 - (i2-i1)
        return np.linspace(0, pas*n, n)
    for i in range(len(t)):
        if t[i] >= t4:
            i4 = i
            break
    n = len(t) - (i2-i1) - (i4-i3)
    return np.linspace(0, pas*n, n)

def recollement(t, li, t1=0, t2=0, t3=0, t4=0):
    if t1 == 0:
        return li
    li = list(li)
    for i in range(len(t)):
        if t[i] >= t1:
            i1 = i
            break
    if t2 == 0:
        return li[:i1]
    for i in range(len(t)):
        if t[i] >= t2:
            i2 = i
            break
    if t3 == 0:
        return li[:i1]+li[i2:]
    for i in range(len(t)):
        if t[i] >= t3:
            i3 = i
            break
    if t4 == 0:
        return li[:i1]+li[i2:i3]
    for i in range(len(t)):
        if t[i] >= t4:
            i4 = i
            break
    return li[:i1]+li[i2:i3]+li[i4:]
    
#%% import du fichier de télémétrie ou simulation de données de télémétrie puis traitement
if simulation:
    t = np.linspace(0, 10, 1000) #100hz 
    av = [np.random.normal(0.30*130, 25) for i in range(1000)]
    ar = [np.random.normal(0.35*130, 20) for i in range(1000)]
    date = time.strftime("%d / %m / %Y à %H:%M", time.localtime())
    Ax, Ay, Az = [np.random.normal(5, 1) for i in range(1000)], [np.random.normal(0, 1) for i in range(1000)], [np.random.normal(-5, 1) for i in range(1000)]

else:
    t, pot0, pot1, Ax, Ay, Az = np.loadtxt(fichier, skiprows=1, unpack=True, delimiter=',')
    t = list(t)
    if pot_invers:
        pot0 = [max_pot_ar - pot0[i] for i in range(len(pot0))]
        pot1 = [max_pot_av - pot1[i] for i in range(len(pot1))]
    if t1 != 0:
        pot0 = recollement(t, pot0, t1, t2, t3, t4)
        pot1 = recollement(t, pot1, t1, t2, t3, t4)
        Ax = recollement(t, Ax, t1, t2, t3, t4)
        Ay = recollement(t, Ay, t1, t2, t3, t4)
        Az = recollement(t, Az, t1, t2, t3, t4)
        t = check_temps(t, t1, t2, t3, t4)
    if pot_invers:
        ar, av = wheel_travel(pot0, False), wheel_travel(pot1, True)
    else: 
        av, ar = wheel_travel(pot0, True), wheel_travel(pot1, False)

#%%
# variables d'exploitation 
plage_bar = np.linspace(0, max(debattement_avant, debattement_arriere), max(debattement_avant, debattement_arriere)+1) # ax2 : intervalles de largeur 1 pour les barres
pav, par = dynamic_sag(av, ar) # ax2 : d'utilisation des suspensions par tranche de 1 mm
sagav, sagar = data_sag(pav, par) # ax2 : sag avant et arriere

x_nuage, y_nuage, coef_nuage = var_nuage_pos(av, ar) # ax3 : coefficients et liste de regression du nuage de position

dt, dav, dar = wheel_speed(t, av, ar) # ax4 : temps adapté aux dérivées de av et ar : vitesses

Delta_pot = [100/130 * (av[i]-ar[i]) for i in range(len(av))] # ax4 : debattement avant - arriere en %

x_plage_dav, x_plage_dar, y_plage_dav, y_plage_dar = tranche_vitesse(dav, dar, echelle_log=vitesse_log) # ax5 : % d'utilisation des suspensions par tranche de vitesse

x_max_dav, x_max_dar = int(tranche_vitesse_max(dav, dar)[0]), int(tranche_vitesse_max(dav, dar)[1]) # ax5 : legende

repart_d = repartition_vitesse(dav, dar) # ax6 : liste de repartion des couples de vitesse

max_scatter = 5500 # ou max(max(dav), -min(dav), max(dar), -min(dar))

delta_use = delta_hist(Delta_pot) #ax8 histogramme du temps selon le Delta de debattement    

delta_max = stat_delta(delta_use) #ax8 maximum affiché

Acc = Vect_Acc(Ax, Ay, Az)

A_avg, A_max = data_acc(Acc) # ax9 : accélération

botav, botar = bottom_compte(t, av, ar) # ax9: bottoms


#%% affichage

# plot des figures 3x3
plt.figure(figsize=(60, 64), layout="tight")
ax1 = plt.subplot(3,2,1)
ax2 = plt.subplot(3,4,3)
ax3 = plt.subplot(3,4,4)
ax4 = plt.subplot(3,2,3)
ax5 = plt.subplot(3,4,7)
ax6 = plt.subplot(3,4,8)
ax7 = plt.subplot(3,2,5)
ax8 = plt.subplot(3,4,11)
ax9 = plt.subplot(3,4,12)
axes = [ax1, ax2, ax3, ax4, ax5, ax6, ax7, ax8, ax9]

ax1.plot(t, av, label="Avant", linewidth=0.6)
ax1.plot(t, ar, label="Arrière", linewidth=0.6)
ax1.legend(loc="upper right")
ax1.set_xlim((min(t), max(t)))
ax1.set_ylim([0, 130])
ax1.set_yticks(np.linspace(0, 120, 7))
ax1.set_xlabel("Temps en s")
ax1.set_ylabel("Débattement en mm")
ax1.set_title("Evolution temporelle du débattement des suspensions")

ax2.bar(plage_bar, pav, width=0.8, align='edge', alpha = 0.35, label='Av ' + str(sagav) + 'mm' + ' (' + str(int(100*sagav/debattement_avant)) + '%)')
ax2.bar(plage_bar, par, width=0.8, align='edge', alpha = 0.35, label='Ar ' + str(sagar) + 'mm'+ ' (' + str(int(100*sagar/debattement_arriere)) + '%)')
ax2.legend(loc='upper right')
ax2.set_title("Répartition du temps par tranche de débattement")
ax2.set_xlabel("Tranche de débattement de 1mm")
ax2.set_ylabel("Temps passé en %")
#ax2.set_xticks(np.linspace(0, 130, 14))

ax3.plot(ar, av, '.', markersize=3, alpha=0.35)
ax3.plot(x_nuage, x_nuage)
ax3.plot(x_nuage, y_nuage, label='a = ' + str(round(coef_nuage, 3)))
ax3.legend(loc='upper right')
ax3.set_title("Nuage des couples de débattement")
ax3.set_ylabel("Roue avant en mm")
ax3.set_xlabel("Roue arrière en mm")
ax3.set_xlim(0)
ax3.set_ylim(0)
#ax3.set_xticks(np.linspace(0, 130, 14))
#ax3.set_yticks(np.linspace(0, 130, 14))

ax4.plot(t, Delta_pot, linewidth=0.6)
ax4.plot((0, t[-1]), (0, 0))
#ax4.legend(loc="upper right")
ax4.set_xlim((min(t), max(t)))
ax4.set_ylim((-100, 100))
ax4.set_xlabel("Temps en s")
ax4.set_ylabel("arriere <- Delta en % -> avant")
ax4.set_title("Différence de débattement dans le temps en %")

ax5.bar(x_plage_dav, y_plage_dav, width=40, align='edge', alpha=0.35, label='Av ' + str(x_max_dav) + ' mm/s')
ax5.bar(x_plage_dar, y_plage_dar, width=40, align='edge', alpha=0.35, label='Ar ' + str(x_max_dar) + ' mm/s')
if vitesse_log:
    ax5.set_xlim(-4000, 4000)
    ax5.set_title("Répartition du log du temps par tranche de vitesse")
    ax5.set_ylabel("log(1+Temps passé en %)")
else:
    ax5.set_xlim(-2000, 2000)
    ax5.set_title("Répartition du temps par tranche de vitesse")
    ax5.set_ylabel("Temps passé en %")
ax5.set_xlabel("Tranche de vitesse de 50 mm/s")
ax5.legend(loc='upper right')

ax6.plot(dar, dav, '.', markersize=3, alpha=0.5)
ax6.plot([-1.1*max_scatter, 1.1*max_scatter], [0, 0], 'k', alpha=0.25)
ax6.plot([0, 0], [-1.1*max_scatter, 1.1*max_scatter], 'k', alpha=0.25)
ax6.text(-max_scatter, 0.85*max_scatter, str(round(repart_d[0], 1)) + '%') #0, haut gauche 
ax6.text(0.70*max_scatter, 0.85*max_scatter, str(round(repart_d[1], 1)) + '%') #1, haut droite
ax6.text(-max_scatter, -0.9*max_scatter, str(round(repart_d[2], 1)) + '%') #2, bas gauche
ax6.text(0.70*max_scatter, -0.9*max_scatter, str(round(repart_d[3], 1)) + '%') #3, bas droite
ax6.set_xlim((-1.1*max_scatter, 1.1*max_scatter))
ax6.set_ylim((-1.1*max_scatter, 1.1*max_scatter))
ax6.set_title("Nuage de compression et rebond")
ax6.set_xlabel('<- rebond : Roue arrière : Compression ->')
ax6.set_ylabel('<- rebond : Roue avant : Compression ->')

#ax7.plot(t, Ax, label="Axe X", linewidth=0.6)
#ax7.plot(t, Ay, label="Axe Y", linewidth=0.6)
#ax7.plot(t, Az, label="Axe Z", linewidth=0.6)
ax7.plot(t, Acc, label="Norme de l'accélération", linewidth=0.6)
ax7.legend(loc="upper right")
ax7.set_xlabel("Temps en s")
ax7.set_ylabel("Accélérations en m/s^2")
ax7.set_title("Accélération du triangle principal en fonction du temps")
ax7.set_xlim((min(t), max(t)))

ax8.bar(np.linspace(-100, 100, 201), delta_use, width=0.8, align='center', label='max : '+str(delta_max)+'%')
ax8.bar((0), delta_use[100], width=0.8)
ax8.legend()
ax8.set_title("Répartition du temps par tranche de Delta av/ar")
ax8.set_xlabel("arrière <- 1 mm de Delta av/ar -> avant")
ax8.set_ylabel("Temps passé en %")

ax9.tick_params(left = False, right = False, labelleft = False, labelbottom = False, bottom = False) 
ax9.text(0.05, 0.1, "Durée \n\nAcc moy \n\nAcc max \n\nBottom av \n\nBottom ar ", fontsize=12)
ax9.text(0.5, 0.1, str(round(max(t), 1))+" s"+"\n\n"+str(round(A_avg, 2))+" g \n\n" + str(round(A_max, 2))+" g \n\n"+str(round(botav, 2))+" s\n\n"+str(round(botar, 2))+" s", fontsize=12)

plt.suptitle("Exploitation des données de télémétrie : essai n°"+nrun+" "+probleme)

plt.show()

#%%
"""
#%%
plt.plot(av, Delta_pot, '.', markersize=3, label='avant')
plt.plot(ar, Delta_pot, '.', markersize=3, label='arrière')
plt.plot((0, 130), (0, 0), 'k')
plt.plot((52, 52), (min(Delta_pot), max(Delta_pot)), 'k', label='shift = 52mm')
plt.legend(loc='upper right')
plt.xlabel("Débattement de la roue en mm")
plt.ylabel("Ar <- Delta -> Av")

#%%
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.scatter(Ax, Ay, Az, s=2)
ax.set_xlabel('Axe X')
ax.set_ylabel('Axe Y')
ax.set_zlabel('Axe Z')

#%%
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.scatter(dar, dav, Delta_pot[1:-1], s=2, alpha=0.5)
ax.plot((0, 0), (0, 0), (min(Delta_pot)-5, max(Delta_pot)+5), 'k')
ax.plot((-3000, 3000), (0, 0), (0, 0), 'k')
ax.plot((0, 0), (-3000, 3000), (0, 0), 'k')
ax.set_xlabel('dar')
ax.set_ylabel('dav')
ax.set_zlabel('Delta')
ax.set_xlim((-3000, 3000))
ax.set_ylim((-3000, 3000))


#%% nuage dav/dar par zones
import matplotlib.patches as mpatch

norme = [0]*len(dav)
for i in range(len(dav)):
    norme[i] = np.sqrt(dav[i]**2 + dar[i]**2)

deciles = np.percentile(norme, np.arange(0, 100, 1))
couleur=['#1f77b4', '#ff7f0e', '#2ca02c']

plt.plot([-1.1*max_scatter, 1.1*max_scatter], [0, 0], 'k', alpha=0.25)
plt.plot([0, 0], [-1.1*max_scatter, 1.1*max_scatter], 'k', alpha=0.25)
plt.text(-max_scatter, 0.85*max_scatter, str(round(repart_d[0], 1)) + '%') #0, haut gauche 
plt.text(0.70*max_scatter, 0.85*max_scatter, str(round(repart_d[1], 1)) + '%') #1, haut droite
plt.text(-max_scatter, -0.9*max_scatter, str(round(repart_d[2], 1)) + '%') #2, bas gauche
plt.text(0.70*max_scatter, -0.9*max_scatter, str(round(repart_d[3], 1)) + '%') #3, bas droite
plt.xlim((-1.1*max_scatter, 1.1*max_scatter))
plt.ylim((-1.1*max_scatter, 1.1*max_scatter))
plt.title("Nuage de compression et rebond")
plt.xlabel('<- rebond : Roue arrière : Compression ->')
plt.ylabel('<- rebond : Roue avant : Compression ->')

for i in range(int(len(norme)/1)):
    if norme[i] <= deciles[94]:
        plt.scatter(dar[i], dav[i], s=3, color=couleur[0])
    elif norme[i] <= deciles[99]:
        plt.scatter(dar[i], dav[i], s=3, color=couleur[1])
    else:
        plt.scatter(dar[i], dav[i], s=3, color=couleur[2])

patch1 = mpatch.Patch(color=couleur[0], label='95%')
patch2 = mpatch.Patch(color=couleur[1], label='99%')
patch3 = mpatch.Patch(color=couleur[2], label='100%')

plt.legend(handles=[patch1, patch2, patch3], loc="center left")
plt.show()
"""

#%% FFT
fichier = "run 0 gopro.csv"
t, pot0, pot1, Ax, Ay, Az = np.loadtxt(fichier, skiprows=1, unpack=True, delimiter=',')
Acc = Vect_Acc(Ax, Ay, Az)

N = len(Acc)

acc_fft = np.abs(np.fft.fft(Acc))/N
acc_freq = np.fft.fftfreq(N, d=t[-1]/N)

plt.plot(acc_freq[:N//2], np.exp(1+acc_fft[:N//2])-np.exp(1), alpha=0.5, label=fichier)
plt.legend()
#plt.ylim(0, 0.6)
plt.ylim(0, 3)

fichier = "run 7.csv"
t, pot0, pot1, Ax, Ay, Az = np.loadtxt(fichier, skiprows=1, unpack=True, delimiter=',')
Acc = Vect_Acc(Ax, Ay, Az)

N = len(Acc)

acc_fft = np.abs(np.fft.fft(Acc))/N
acc_freq = np.fft.fftfreq(N, d=t[-1]/N)

plt.plot(acc_freq[:N//2], np.exp(1+acc_fft[:N//2])-np.exp(1), alpha=0.5, label=fichier)
plt.legend()
#plt.ylim(0, 0.6)
plt.ylim(0, 3)

plt.show()











"""

Code d'exploitation du système de télémétrie

"""

fichier_calibration = "/Users/nathan/Documents/mpsi/TIPE/donnes expérimentales/26 decembre/calibration 26 decembre.csv"
fichier = "/Users/nathan/Documents/mpsi/TIPE/donnes expérimentales/26 decembre/run 2.csv"
nrun = fichier[-5]
saut_de_chaine = False
chute = False
crevaison = False

vitesse_log = True
correction_temps = True

Tmoyennage = 0.2

#%% TRAITEMENT DU SIGNAL - NE PAS MODIFIER
import matplotlib.pyplot as plt
import numpy as np
import time

# Calibration
cali = np.loadtxt(fichier_calibration, skiprows=1, unpack=True, delimiter=',')
pot_invers = True

# progressivité du vélo 
shock_travel = [0, 3.3, 6.6, 10, 13.4, 16.9, 20.5, 24.1, 27.7, 31.4, 35.1, 38.9, 42.7, 46.5]
rear_travel = np.linspace(0, 130, 14)
rc = np.polyfit(shock_travel, rear_travel, 3)

# variables de l'expérience
debattement_avant = 130 #en mm
debattement_arriere = 130 #en mm
debattement_shock = 47 #en mm
longueur_pot_av = 150 #en mm
longueur_pot_ar = 100 #en mm
max_pot_av = 26270
max_pot_ar = 26270

if pot_invers:
    cali[1] = [max_pot_ar - cali[1][i] for i in range(len(cali[1]))]
    cali[2] = [max_pot_av - cali[2][i] for i in range(len(cali[2]))]
pot_ar_max_travel = (max(cali[1]) - min(cali[1])) * (longueur_pot_ar / max_pot_ar)

# fonctions de traitement
def conversion_avant(pot: list) -> list:
    m, M = min(cali[2]), max(cali[2])
    n = len(pot)
    av = [0]*n
    for i in range(n):
        av[i] = (pot[i] - m) * (longueur_pot_av / max_pot_av)
    return av

def conversion_arrière(pot: list) -> list:
    m, M = min(cali[1]), max(cali[1])
    n = len(pot)
    pot_conv = [0]*n
    zero_ar = min(pot) * (longueur_pot_ar / max_pot_ar)    
    for i in range(n):
        pot_conv[i] = (pot[i] * (longueur_pot_ar / max_pot_ar) - zero_ar) * (debattement_shock / pot_ar_max_travel)
    #conversion de pot à wheel travel
    for i in range(n):
        pot_conv[i] = rc[3] + rc[2]*pot_conv[i] + rc[1]*pot_conv[i]**2 + rc[0]*pot_conv[i]**3      
    return pot_conv
    
def wheel_travel(pot: list, front=True) -> list: #conversion potentiometre -> wheel travel
    n = len(pot)
    pot_conv = [0]*n
    if front:
        zero_av = min(pot) * (longueur_pot_av / max_pot_av)
        for i in range(n):
            pot_conv[i] = pot[i] * (longueur_pot_av / max_pot_av) - zero_av
    else: #rear
        zero_ar = min(pot) * (longueur_pot_ar / max_pot_ar)    
        for i in range(n):
            pot_conv[i] = (pot[i] * (longueur_pot_ar / max_pot_ar) - zero_ar) * (debattement_shock / pot_ar_max_travel)
        #conversion de pot à wheel travel
        for i in range(n):
            pot_conv[i] = rc[3] + rc[2]*pot_conv[i] + rc[1]*pot_conv[i]**2 + rc[0]*pot_conv[i]**3      
    return pot_conv

def wheel_speed(t, av, ar):
    dav = [(av[i+1]-av[i-1])/(t[i+1]-t[i-1]) for i in range(1, len(t)-1)]
    dar = [(ar[i+1]-ar[i-1])/(t[i+1]-t[i-1]) for i in range(1, len(t)-1)]
    dt = t[1:-1]
    return dt, dav, dar

def repartition_vitesse(dav, dar):
    """
    in : dav et dar sont les outputs de wheel_speed
    out : liste de repartion des couples de vitesse dans l'ordre :
        0, haut gauche 
        1, haut droite
        2, bas gauche
        3, bas droite
    """
    repart_d = [0]*4
    n = len(dar)
    for i in range(n):
        if dar[i] > 0:
            if dav[i] > 0:
                repart_d[1] += 100/n
            else:
                repart_d[3] += 100/n
        else:
            if dav[i] > 0:
                repart_d[0] += 100/n
            else:
                repart_d[2] += 100/n
    return repart_d

def var_nuage_pos(av, ar):
    reg_nuage = np.polyfit(ar, av, 1)
    x_nuage = np.linspace(0, 130, 14)
    y_nuage = [reg_nuage[0]*x_nuage[i] + reg_nuage[1] for i in range(len(x_nuage))]
    return x_nuage, y_nuage, reg_nuage[0]

def tranche_vitesse(dav: list, dar: list, echelle_log=False, max_v=4000, largeur_v=50) -> list: #affichage graphique
    """
    av et ar sont les outputs de wheel_speed
    renvoie des listes de % d'utilisation des suspensions par tranche de vitesse
    """
    y_plage_dav, x_plage_dav = np.histogram(dav, bins=np.linspace(-max_v, max_v, int(2*max_v/largeur_v+1)))
    y_plage_dar, x_plage_dar = np.histogram(dar, bins=np.linspace(-max_v, max_v, int(2*max_v/largeur_v+1)))
    lenav, lenar = len(dav), len(dar)
    if vitesse_log:
        y_plage_dav, y_plage_dar = np.log(1+100*y_plage_dav/lenav), np.log(1+100*y_plage_dar/lenar)
    else:
        y_plage_dav, y_plage_dar = 100*y_plage_dav/lenav, 100*y_plage_dar/lenar
    return x_plage_dav, x_plage_dar, y_plage_dav, y_plage_dar

def tranche_vitesse_max(dav: list, dar: list, max_v=500) -> list: #affichage valeur
    """
    av et ar sont les outputs de wheel_speed
    renvoie des listes de % d'utilisation des suspensions par tranche de vitesse
    """
    y_plage_dav_fin, x_plage_dav_fin = np.histogram(dav, bins=np.linspace(-max_v, max_v, 2*max_v+1))
    y_plage_dar_fin, x_plage_dar_fin = np.histogram(dar, bins=np.linspace(-max_v, max_v, 2*max_v+1))
    y_max_dar = max(y_plage_dar_fin)
    for i in range(len(x_plage_dar_fin)-1):
        if y_plage_dar_fin[i] == y_max_dar:
            x_max_dar = int(x_plage_dar_fin[i])
            break       
    y_max_dav = max(y_plage_dav_fin)
    for i in range(len(x_plage_dav_fin)-1):
        if y_plage_dav_fin[i] == y_max_dav:
            x_max_dav = int(x_plage_dav_fin[i])
            break        
    return x_max_dav, x_max_dar

def data_sag(pav, par, plage_av, plage_ar):
    mav = max(pav[15:])
    for i in range(len(pav)):
        if pav[i] == mav:
            sagav = int(plage_av[i])
    mar = max(par[15:])
    for i in range(len(par)):
        if par[i] == mar:
            sagar = int(plage_ar[i])
    return sagav, sagar

def delta_hist(delta) -> list:
    """
    av et ar sont les outputs de wheel_travel
    renvoie des listes de % de temps passé par delta de debattement
    """
    delta_use_y, delta_use_x = np.histogram(Delta_pot, bins=np.linspace(-100, 100, 201))
    ndelta = len(Delta_pot)
    delta_use_y = 100/ndelta*delta_use_y
    return delta_use_x, delta_use_y

def stat_delta(delta_use_x, delta_use_y):
    delta_use_y_max = max(delta_use_y)
    for i in range(len(delta_use_x)-1):
        if delta_use_y[i] == delta_use_y_max:
            delta_max = int(delta_use_x[i])
            return delta_max    

def Vect_Acc(Ax, Ay, Az):
    Acc = [0]*len(Ax)
    for i in range(len(Ax)):
        Acc[i] = np.sqrt(Ax[i]**2 + Ay[i]**2 + Az[i]**2) - 10
    return Acc

def data_acc(Acc):
    return round(np.mean(Acc)/10, 2), round(max(Acc)/10, 1)

def bottom_compte(t, av, ar, nombre=True):
    """
    Renvoie le temps passé à bottom les suspensions
    """
    botav, botar = 0, 0
    for i in range(len(t)):
        if av[i] > 0.96*debattement_avant:
            botav += 1
        if ar[i] > 0.96*debattement_arriere:
            botar += 1
    if not nombre:
        periode = t[-1]/len(t)
        botav *= periode
        botar *= periode
    return botav, botar

def indice(val, li):
    """
    Renvoie l'indice de la valeur la plus proche de 'val' dans une liste ordonnée
    """
    n = len(li)
    i = 0
    while val > li[i] and i < n-1:
        i += 1
    if abs(val-li[i-1]) < abs(val-li[i]):
        return i-1
    return i

def détection_pauses(tm, Accm, tol=1.6):
    pauses = []
    k = -1
    for i in range(len(Accm)):
        if abs(Accm[i]) < tol and k == -1:
            k = i
        if abs(Accm[i]) > tol and k != -1:
            if i > k+1/Tmoyennage: #mal fait
                pauses += [k, i]
            k = -1
        if k != -1 and i == len(Accm)-1:
            pauses += [k, i]
    for i in range(len(pauses)):
        pauses[i] = round(tm[pauses[i]], 1)
    return pauses

def cut_pauses(pauses, t, X):
    t = list(t)
    l_indices = []
    for p in pauses:
        l_indices.append(indice(p, t))
    X = list(X)
    Y = []
    n = len(l_indices)//2
    i = 0
    for k in range(n):
        j = l_indices[2*k]
        Y += X[i:j]
        i = l_indices[2*k+1]
    Y += X[i:-1]
    if X == t:
        T = t[-1]/len(t)
        Y = np.linspace(0, T*len(Y), len(Y))
    return Y

def moyennage(t: list, X: list, T=1, align='center'):
    """
    Renvoie une version moyennée sur T secondes glissantes de la liste X et sa liste de temps adaptée
    IN : liste t de temps en secondes ordonée, liste X à lisser, T la période de moyennage
    OUT : tm et Xm les deux listes moyennées
    
    si align='center' les valeurs de tm sont décalées d'un demi intervalle
    si align='left' elles prennent la valeur de t au début de l'intervalle
    si align='right' elles prennent la valeur de t au début de l'intervalle
    """
    import numpy as np
    assert T <= t[-1]/2, 'On ne peut pas moyenner sur une période si longue !'
    tm, Xm = [], []
    dt = len(t)*T/t[-1]
    n = 0
    while (n+1)*T <= t[-1]:
        a, b = int(round(n*dt, 0)), int(round((n+1)*dt, 0))
        if align=='left':
            tm.append((n)*T)
        elif align=='right':
            tm.append((n+1)*T)
        else:
            tm.append((n+0.5)*T)
        Xm.append(np.mean(X[a:b]))
        n += 1
    return tm, Xm

# import du fichier de télémétrie puis traitement
t, pot0, pot1, Ax, Ay, Az = np.loadtxt(fichier, skiprows=1, unpack=True, delimiter=',')
t = list(t)
if pot_invers:
    pot0 = [max_pot_ar - pot0[i] for i in range(len(pot0))]
    pot1 = [max_pot_av - pot1[i] for i in range(len(pot1))]
if correction_temps:
    Acc = Vect_Acc(Ax, Ay, Az)
    tm, Accm = moyennage(t, Acc, Tmoyennage)
    pauses = détection_pauses(tm, Accm)
    pot0 = cut_pauses(pauses, t, pot0)
    pot1 = cut_pauses(pauses, t, pot1)
    Ax = cut_pauses(pauses, t, Ax)
    Ay = cut_pauses(pauses, t, Ay)
    Az = cut_pauses(pauses, t, Az)
    t = cut_pauses(pauses, t, t)
if pot_invers:
    ar, av = wheel_travel(pot0, False), wheel_travel(pot1, True)
else: 
    av, ar = wheel_travel(pot0, True), wheel_travel(pot1, False)

# variables d'exploitation 
botav, botar = bottom_compte(t, av, ar) # ax1: bottoms

par, plage_ar = np.histogram(ar, bins=np.linspace(0, debattement_arriere, debattement_arriere+1))
pav, plage_av = np.histogram(av, bins=np.linspace(0, debattement_avant, debattement_avant+1))
pav, par = 100*pav/len(t), 100*par/len(t)
sagav, sagar = data_sag(pav, par, plage_av, plage_ar) # ax2 : sag avant et arriere

x_nuage, y_nuage, coef_nuage = var_nuage_pos(av, ar) # ax3 : coefficients et liste de regression du nuage de position

dt, dav, dar = wheel_speed(t, av, ar) # ax4 : temps adapté aux dérivées de av et ar : vitesses
Delta_pot = [100/130 * (av[i]-ar[i]) for i in range(len(av))] # ax4 : debattement avant - arriere en %

x_plage_dav, x_plage_dar, y_plage_dav, y_plage_dar = tranche_vitesse(dav, dar) #ax5
x_max_dav, x_max_dar = tranche_vitesse_max(dav, dar) #ax5

repart_d = repartition_vitesse(dav, dar) # ax6 : liste de repartion des couples de vitesse
max_scatter = 4500 #ax6

delta_use_x, delta_use_y = delta_hist(Delta_pot) #ax7
delta_max = stat_delta(delta_use_x, delta_use_y) #ax7

Acc = Vect_Acc(Ax, Ay, Az)
tm, Accm = moyennage(t, Acc, Tmoyennage) # ax8 : accélération
A_avg, A_max = data_acc(Acc) # ax8 : accélération

#texte problemes rencontrés
probleme = ""
pb_vide = True
if saut_de_chaine:
    pb_vide = False
    probleme += "saut de chaine"
if crevaison:
    pb_vide = False
    if len(probleme) != 0:
        probleme += ", "
    probleme += "crevaison"
if chute:
    pb_vide = False
    if len(probleme) != 0:
        probleme += ", "
    probleme += "chute"
if correction_temps:
    pb_vide = False
    if len(probleme) != 0:
        probleme += ", "
    probleme += "temps corrigé"
if not pb_vide:
    probleme = "("+probleme+")"

# affichage
plt.figure(figsize=(16, 9), layout="tight")
ax1 = plt.subplot(3,2,1)
ax2 = plt.subplot(3,4,3)
ax3 = plt.subplot(3,4,4)
ax4 = plt.subplot(3,2,3)
ax5 = plt.subplot(3,4,7)
ax6 = plt.subplot(3,4,8)
ax7 = plt.subplot(3,2,5)
ax8 = plt.subplot(3,2,6)
axes = [ax1, ax2, ax3, ax4, ax5, ax6, ax7, ax8]

ax1.plot(0, 0, 'k', lw=0, label='Temps = '+str(round(max(t), 1))+" s")
ax1.plot(t, av, label="Avant : bottom = "+str(round(botav, 2))+" fois", linewidth=0.6, alpha=0.9)
ax1.plot(t, ar, label="Arrière : bottom = "+str(round(botar, 2))+" fois", linewidth=0.6, alpha=0.9)
ax1.legend(loc="lower center", fontsize=9)
ax1.set_xlim((min(t), max(t)))
ax1.set_ylim([0, 130])
ax1.set_yticks(np.linspace(0, 120, 7))
ax1.set_xlabel("Temps en s")
ax1.set_ylabel("Débattement en mm")
ax1.set_title("Evolution temporelle du débattement des suspensions")

#ax2.hist(av, bins=np.linspace(0, debattement_avant, debattement_avant+1), alpha=0.65, label='Av ' + str(sagav) + 'mm' + ' (' + str(int(100*sagav/debattement_avant)) + '%)')
#ax2.hist(ar, bins=np.linspace(0, debattement_arriere, debattement_arriere+1), alpha=0.65, label='Ar ' + str(sagar) + 'mm' + ' (' + str(int(100*sagar/debattement_arriere)) + '%)')
ax2.bar(plage_av[:-1], pav, width=1, alpha=0.65, label='Av '+str(sagav)+'mm ('+str(int(100*sagav/debattement_avant)) + '%)')
ax2.bar(plage_ar[:-1], par, width=1, alpha=0.65, label='Ar '+str(sagar)+'mm ('+str(int(100*sagar/debattement_arriere)) + '%)')
ax2.legend(loc='upper right')
ax2.set_title("Histogramme des écrasements")
ax2.set_xlabel("Tranche de débattement de 1mm")
ax2.set_ylabel("Temps passé en %")

ax3.plot(ar, av, '.', markersize=3, alpha=0.35)
ax3.plot(x_nuage, x_nuage)
ax3.plot(x_nuage, y_nuage, label='a = ' + str(round(coef_nuage, 3)))
ax3.legend(loc='upper right')
ax3.set_title("Nuage des couples de débattement")
ax3.set_ylabel("Roue avant en mm")
ax3.set_xlabel("Roue arrière en mm")
ax3.set_xlim(0)
ax3.set_ylim(0)

#ax3.scatter(av[1:-1], dav, label='av', s=5, alpha=0.5)
#ax3.scatter(ar[1:-1], dar, label='ar', s=5, alpha=0.5)
#ax3.legend()

ax4.plot(t, Delta_pot, linewidth=0.6, alpha=0.9)
ax4.plot((0, t[-1]), (0, 0))
ax4.set_xlim((min(t), max(t)))
ax4.set_ylim((-100, 100))
ax4.set_xlabel("Temps en s")
ax4.set_ylabel("arriere <- Delta en % -> avant")
ax4.set_title("Différence temporelle d'écrasement en %")

ax5.bar(x_plage_dav[:-1], y_plage_dav, width=50, alpha=0.65, align='edge', label='Av ' + str(x_max_dav) + ' mm/s')
ax5.bar(x_plage_dar[:-1], y_plage_dar, width=50, alpha=0.65, align='edge', label='Ar ' + str(x_max_dar) + ' mm/s')
if vitesse_log:
    ax5.set_xlim(-4000, 4000)
    ax5.set_title("Histogramme des vitesses (éch. log)")
    ax5.set_ylabel("log(1+Temps passé en %)")
else:
    ax5.set_xlim(-2000, 2000)
    ax5.set_title("Histogramme des vitesses")
    ax5.set_ylabel("Temps passé en %")
ax5.set_xlabel("Tranche de vitesse de 50 mm/s")
ax5.legend(loc='upper right')

ax6.plot(dar, dav, '.', markersize=3, alpha=0.5)
ax6.plot([-1.1*max_scatter, 1.1*max_scatter], [0, 0], 'k', alpha=0.25)
ax6.plot([0, 0], [-1.1*max_scatter, 1.1*max_scatter], 'k', alpha=0.25)
ax6.text(-0.9*max_scatter, 0.8*max_scatter, str(round(repart_d[0], 1)) + '%') #0, haut gauche 
ax6.text(0.65*max_scatter, 0.8*max_scatter, str(round(repart_d[1], 1)) + '%') #1, haut droite
ax6.text(-0.9*max_scatter, -0.9*max_scatter, str(round(repart_d[2], 1)) + '%') #2, bas gauche
ax6.text(0.65*max_scatter, -0.9*max_scatter, str(round(repart_d[3], 1)) + '%') #3, bas droite
ax6.set_xlim((-max_scatter, max_scatter))
ax6.set_ylim((-max_scatter, max_scatter))
ax6.set_title("Nuage de compression et rebond")
ax6.set_xlabel('<- rebond : Roue arrière : Compression ->')
ax6.set_ylabel('<- rebond : Roue avant : Compression ->')

ax7.bar(delta_use_x[:-1], delta_use_y, width=1, alpha=0.8, label='max : '+str(delta_max)+'%')
ax7.bar(0, 1.2*max(delta_use_y), width=1)
ax7.legend()
ax7.set_title("Histogramme du Delta avant/arrière")
ax7.set_xlabel("arrière <- 1 mm de Delta av/ar -> avant")
ax7.set_ylabel("Temps passé en %")

ax8.plot(tm, Accm, label="Norme de l'accélération\nMoy = "+str(round(A_avg, 2))+" g\nMax = "+str(round(A_max, 2))+" g", linewidth=0.8)
ax8.legend(loc="upper center", fontsize=9)
ax8.set_xlabel("Temps en s")
ax8.set_ylabel("Accélérations en m/s^2")
ax8.set_title("Accélération du triangle principal en fonction du temps")
ax8.set_xlim((min(t), max(t)))

plt.suptitle("Exploitation des données de télémétrie : essai n°"+nrun+" "+probleme)

plt.show()


